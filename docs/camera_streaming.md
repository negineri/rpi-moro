# ラズベリーパイでの USB カメラストリーミング機能の実装方針

## 1. 概要

ラズベリーパイに接続された USB カメラの映像をリアルタイムでストリーミングし、ウェブブラウザ経由で確認できる機能を実装します。これにより遠隔地からカメラの映像をモニタリングすることが可能になります。

## 2. 技術スタック

### 必要なライブラリ・フレームワーク

- **OpenCV**: カメラからの映像キャプチャと基本的な画像処理
- **Flask**: ウェブサーバーとしての機能提供
- **Flask-SocketIO**: リアルタイム双方向通信の実現
- **NumPy**: 画像処理の効率化
- **imutils**: 画像リサイズなどの便利機能

## 3. アーキテクチャ設計

### コンポーネント構成

1. **カメラモジュール**:

   - USB カメラとの接続管理
   - フレーム取得処理
   - 基本的な画像処理（必要に応じて）

2. **ストリーミングサーバー**:

   - ウェブサーバー機能
   - WebSocket を使用したリアルタイムストリーミング
   - クライアントとの通信管理

3. **フロントエンド**:
   - ストリーミング映像表示用のシンプルなウェブページ
   - 必要に応じたカメラ制御インターフェース

### データフロー

```
USBカメラ → カメラモジュール → ストリーミングサーバー → ウェブブラウザ（クライアント）
```

## 4. 機能要件

### 基本機能

- USB カメラの検出と接続
- 映像のキャプチャとエンコード
- ブラウザでのリアルタイム表示
- サーバーの起動・停止制御

### 拡張機能（オプション）

- 複数カメラのサポート
- 映像品質・解像度の調整機能
- 静止画キャプチャ機能
- タイムラプス録画機能

## 5. 実装計画

### フェーズ 1: 基本実装

1. カメラモジュールの作成

   - USB カメラ接続とフレーム取得機能の実装
   - 例外処理の追加

2. ストリーミングサーバーの実装

   - Flask アプリケーションの構築
   - WebSocket ストリーミング機能の実装

3. シンプルなウェブインターフェースの作成
   - ストリーミング表示ページの実装

### フェーズ 2: 機能拡張

1. カメラ設定調整機能の追加
2. 複数カメラサポートの実装
3. 録画機能の追加

## 6. ディレクトリ構造

プロジェクト既存の構造に合わせた形で以下のように実装します：

```
src/
    moro/
        modules/
            camera/
                __init__.py
                camera.py       # カメラ接続・制御
                streaming.py    # ストリーミング処理
        services/
            web/
                __init__.py
                server.py       # Webサーバー実装
                templates/      # HTMLテンプレート
                static/         # CSS, JavaScriptなど
        cli/
            camera_commands.py  # カメラ関連のCLIコマンド
tests/
    camera/
        test_camera.py
        test_streaming.py
```

## 7. テスト戦略

- **単体テスト**: 各モジュールの機能をテスト
- **統合テスト**: カメラ接続からストリーミングまでの一連の流れのテスト
- **モックテスト**: 実際のカメラがなくてもテスト可能な構成

## 8. セキュリティ考慮事項

- 認証機能の実装（必要に応じて）
- ストリーミングへのアクセス制限
- 安全なデータ転送（必要に応じて HTTPS）

## 9. パフォーマンス最適化と帯域削減

### 帯域削減機能

ネットワークの状況や使用環境に応じて、ストリーミングの帯域を削減するための複数の機能を実装しています：

1. **解像度の削減**

   - 元のカメラ解像度から縮小した映像をストリーミング
   - `--stream-resolution` オプションで幅と高さを指定可能
   - 例：`moro camera stream --stream-resolution 320 240`

2. **フレームレートの調整**

   - FPS を下げることで帯域を削減（デフォルト 15FPS）
   - `--fps` オプションで調整可能
   - 例：`moro camera stream --fps 5`

3. **JPEG 品質の調整**

   - 圧縮品質を調整することで帯域を削減（デフォルト品質 70）
   - `--quality` オプションで 0〜100 の範囲で調整可能
   - 例：`moro camera stream --quality 50`

4. **グレースケール変換**

   - カラー情報を削除して帯域を約 1/3 に削減
   - `--grayscale` フラグで有効化
   - 例：`moro camera stream --grayscale`

5. **動き検出によるフレーム間引き**

   - 静止シーンでは新しいフレームの送信を減らして帯域を削減
   - `--motion-detection` フラグで有効化
   - `--motion-threshold` で検出感度を調整可能（値が大きいほど感度が下がる）
   - 例：`moro camera stream --motion-detection --motion-threshold 0.1`

6. **組み合わせ使用**
   - 複数の機能を組み合わせてさらに帯域を削減可能
   - 例：`moro camera stream --fps 5 --quality 50 --stream-resolution 320 240 --grayscale --motion-detection`

### HLS ストリーミングについて

HTTP Live Streaming (HLS) は、特にインターネット経由のストリーミングに効果的な技術です：

- **利点**:

  - 適応ビットレートストリーミング（ネットワーク状況に応じて品質を自動調整）
  - 異なる解像度・ビットレートのストリームを提供可能
  - 広く対応されているプロトコル（iOS, Android, ほとんどのブラウザで対応）

- **欠点**:

  - リアルタイム性が低い（数秒の遅延が発生）
  - 実装が複雑
  - エンコード処理の負荷が高い

- **実装計画**:
  - フェーズ 3 として、FFmpeg を用いた HLS 対応を検討中

### 最適な帯域削減方法の選択

用途に応じた最適な帯域削減方法の選択ガイド：

| 用途       | 推奨設定                                                       |
| ---------- | -------------------------------------------------------------- |
| 高品質監視 | `--quality 70 --fps 15`                                        |
| 通常監視   | `--stream-resolution 640 480 --quality 60 --fps 10`            |
| 低帯域環境 | `--stream-resolution 320 240 --quality 50 --fps 5 --grayscale` |
| 静的シーン | `--motion-detection --motion-threshold 0.05` と組み合わせる    |

## 10. 実装スケジュール

1. カメラモジュール: 1 週間
2. ストリーミングサーバー: 1 週間
3. ウェブインターフェース: 3 日間
4. テストと最適化: 3 日間

合計: 約 2.5 週間

## 11. 参考資料

- OpenCV ドキュメント: https://docs.opencv.org/
- Flask ドキュメント: https://flask.palletsprojects.com/
- Flask-SocketIO ドキュメント: https://flask-socketio.readthedocs.io/
